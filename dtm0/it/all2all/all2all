#!/bin/bash
#set -x
set -e

MOTR_ROOT=$(realpath ../../..)
MOTR_UTILS_DIR=${MOTR_ROOT}/utils
MOTR_ST_UTILS_DIR=${MOTR_ROOT}/motr/st/utils/
MOTR_VAR_DIR=/var/motr
TEST_ROOT=$MOTR_VAR_DIR/all2all_test
CURRENT_CDF=$PWD/test.yaml
CONFD_XC=/var/lib/hare/confd.xc
LOOP_IMG_DIR=$TEST_ROOT

M0D_DIR_COMMON=$MOTR_VAR_DIR/m0d-0x720000000000000

M0D_ENDPOINTS=()
M0D_FIDS_DEC=()
M0D_FIDS_HEX=()
M0D_PIDS=()

POOL_WIDTH=4
IPOOL_WIDTH=2

. ${MOTR_ROOT}/scripts/addb-py/chronometry/common/common_funcs


function stop_cluster()
{
    hctl shutdown
}

function bootstrap_cluster()
{
    hctl bootstrap --mkfs $CURRENT_CDF
}

function get_m0d_pids()
{
    local pids=""
    local pid

    for fid in ${M0D_FIDS_HEX[@]} ; do
        pid=$(ps ax | grep m0d | grep $fid | awk '{ print $1; }')
        M0D_PIDS+=($pid)
        pids+="$pid "
    done

    _info "m0d PIDs: $pids"
}

function get_params_for_ha_msgs()
{
    local json_out=$(hctl status --json | jq -r '.nodes[] | .svcs[] | select( .name | contains("ioservice"))')
    M0D_ENDPOINTS=($(echo $json_out | jq -r '.ep' | sed -E 's/.*@tcp[:](.*)/\1/'))
    M0D_FIDS_HEX=($(echo $json_out | jq -r '.fid' | sed -E 's/0x720+([0-9][:]0x[A-Za-z0-9]+)/\1/'))
    M0D_FIDS_DEC=($(echo $json_out | jq -r '.fid' | sed -E 's/0x720+([0-9][:])(0x[A-Za-z0-9]+)/printf "%s%d" \1 \2/e'))
}

function ha_msg_send_transient()
{
    # Here we send "TRANSIENT" messages to trigger start of
    # HA messages handling on the m0d side as dtm0 doesn't
    # handle them until "TRANSIENT" received due to incomplete
    # implementation on the Hare side.
    for i in $(seq 0 $((${#M0D_ENDPOINTS[@]}-1))) ; do
        for j in $(seq 0 $((${#M0D_FIDS_DEC[@]}-1))) ; do
            if [[ $i -ne $j ]]; then
                $MOTR_ST_UTILS_DIR/ha_msg_send.sh "${M0D_ENDPOINTS[$i]}" "^r|${M0D_FIDS_DEC[$j]}" "transient"
                break
            fi
        done
    done
}

function ha_msg_send_online()
{
    # Here we send "ONLINE" messages to trigger connections logic.
    for i in $(seq 0 $((${#M0D_ENDPOINTS[@]}-1))) ; do
        for j in $(seq 0 $((${#M0D_FIDS_DEC[@]}-1))) ; do
            if [[ $i -ne $j ]]; then
                $MOTR_ST_UTILS_DIR/ha_msg_send.sh "${M0D_ENDPOINTS[$i]}" "^r|${M0D_FIDS_DEC[$j]}" "online"
            fi
        done
    done
}

function expected_trace_lines_num()
{
    local pattern="$1"
    local exp_cnt=$2
    local cnt

    for i in ${!M0D_PIDS[@]} ; do
        cnt=$($MOTR_ROOT/utils/trace/m0trace -i "${M0D_DIR_COMMON}${M0D_FIDS_HEX[i]}/m0trace.${M0D_PIDS[i]}" | grep "$pattern" | wc -l)
        if [[ $cnt -ne $exp_cnt ]]; then
            return 1
        fi
    done

    return 0
}

function fail()
{
    _err "$1"
    stop_cluster
    _err "TEST STATUS: FAIL"
    exit 1
}

function main()
{
    ${MOTR_UTILS_DIR}/m0setup --init-loop-only -s 1 -d ${TEST_ROOT} --pool-width ${POOL_WIDTH} --ipool-width ${IPOOL_WIDTH}

    _info "Bootstrapping the cluster using Hare..."
    bootstrap_cluster

    get_params_for_ha_msgs
    get_m0d_pids

    _info "Checking traces..."
    expected_trace_lines_num "evented_proc_state" 0 || {
        fail "HA event handled instead of to be skipped, exiting."
    }

    _info "Sending TRANSIENT notifications to trigger HA messages handling..."
    ha_msg_send_transient

    _info "Checking traces..."
    expected_trace_lines_num "TRANSIENT received" 1 || {
        fail "Trigger message is not received, exiting."
    }

    _info "Sending ONLINE notifications to trigger connections logic..."
    ha_msg_send_online

    _info "Checking traces..."
    expected_trace_lines_num "DTM0 service: connected" $((${#M0D_ENDPOINTS[@]}-1)) || {
        fail "Process is not connected, exiting"
    }

    stop_cluster

    _info "TEST STATUS: PASSED"
}

main
